/**
 * @file 消息接受
 * @author cxl(chenxinle@baidu.com)
 */

var inherits = require('util').inherits;
var Writable = require('stream').Writable;
var headerDecode = require('./header').decode;
var bodyDecode = require('./body').decode;
var Message = require('../Message');

var CONST = require('../const');

function Receiver() {
    Writable.apply(this, arguments);
    // 还需要读取的body长度
    this._bodyLen = 0;
    // 当前缓存的未处理的body原始数据
    this._body = [];
}

inherits(Receiver, Writable);

/**
 * 信息处理
 *
 * @param {Buffer} buffer 原始数据
 * @return {Buffer}
 */
Receiver.prototype.process = function (buffer) {
    // 如果还未读取header 先尝试读取一下
    if (!this._header && buffer.length >= CONST.HEADER_SIZE) {
        var header = this._header = headerDecode(buffer.slice(0, CONST.HEADER_SIZE));
        this._bodyLen = header.len;
        buffer = buffer.slice(CONST.HEADER_SIZE);
    }

    // 尝试读取body
    if (this._bodyLen > 0 && buffer.length > 0) {
        var len = Math.min(this._bodyLen, buffer.length);
        this._body.push(buffer.slice(0, len));
        buffer = buffer.slice(len);
        this._bodyLen -= len;
    }

    // 如果header与body都已读取完成就可以开始处理了
    if (this._bodyLen === 0 && this._header) {
        var msg = new Message();
        msg.setHeader(this._header);
        // 清除缓存的header
        this._header = null;

        var body = this._body;
        if (body.length >= 0) {
            body = bodyDecode(msg.mtype, Buffer.concat(body));
        }

        if (body) {
            msg.setBody(body);
        }
        else {
            // 编码失败提示
            this.emit('emptyBody', msg);
        }
        // 清除缓存的body
        this._body = [];

        this.emit('message', msg);
    }

    return buffer;
};

/**
 * write
 *
 * @override
 * @param {Buffer} data 原始数据
 * @param {string} encoding 编码方式
 * @param {Function} done 完成回调
 */
Receiver.prototype._write = function (data, encoding, done) {
    var buffer = [data];
    // 如果之前有未处理完的数据先拼接起来
    if (this._buffer) {
        buffer.unshift(this._buffer);
    }

    buffer = Buffer.concat(buffer);
    
    // 如果解析出现错误，清零&继续
    try {
        var len;
        do {
            len = buffer.length;
            buffer = this.process(buffer);
        }
        while (buffer.length < len);
        // 保留未处理的数据
        this._buffer = buffer;
    } catch (e) {
        if (this._buffer) {
            this._buffer = [];
        }
    }

    done();
};

module.exports = Receiver;
