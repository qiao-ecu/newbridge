/**
 * @file 建立链接
 * @author cxl(chenxinle@baidu.com)
 */

var inject = require('reconnect-core');
var net = require('net');
var Receiver = require('../codec/Receiver');
var curry = require('../util/curry');
var CONST = require('../const');

/**
 * 应答收到的消息
 *
 * @param {Object} core 沟通内核
 * @param {Object} msg 消息对象
 */
function ackMsg(core, msg) {
    var type = CONST.MSG.RESPONSE;
    var cmd;

    // 特殊响应平台的心跳检测
    if (msg.cmd === CONST.CMD.EX_HEARTBEAT) {
        cmd = CONST.CMD.EX_HEARTBEAT;
    }
    else {
        cmd = CONST.CMD.EX_ACK_MSG;
    }

    core._send(type, cmd);
}

/**
 * 沟通建立成功处理
 *
 * @param {Object} core 沟通内核
 * @param {Function} resolve resolve
 */
function connectHandler(core, socket, resolve) {
    var receiver = new Receiver();
    receiver.on('message', curry(ackMsg, core));
    receiver.on('message', core._msgHandler.bind(core));
    receiver.on('emptyBody', function (msg) {
        core.logger.warn('receive msg with empty body %s [%s:%s]', msg.id, msg.type, msg.cmd);
    });
    
    core._socket = socket;
    socket.pipe(receiver);
    resolve();
}

/**
 * 建立链接
 *
 * @public
 * @param {Object} core 沟通内核
 * @return {Promise}
 */
module.exports = function (core) {
    var config = core._config;
    var addressArray = config.serverip;
    
    // build you own reconnect module
    var reconnect = core._con = inject(function () {
        // arguments are what you passed to .connect
        // this is the reconnect instance
        return net.connect.apply(null, arguments);
    });
    
    core._reconnecting = false;
    var promise = new Promise(function (resolve) {
        // We do not implementation retry logic because it's demo only.
        var address = addressArray[0].split(',');
        
        reconnect({
            // all options are optional
            initialDelay: 1e3,
            maxDelay: 30e3,
            type: 'fibonacci',      // available: fibonacci, exponential
            failAfter: Infinity,
            randomisationFactor: 0,
            immediate: false
            }, function (stream) {
                // Do nothing because we have used pipe.
            }
        )
        .on('connect', function (con) {
            curry(connectHandler, core, con, resolve)();
            if (core._reconnecting) {
                core.logger.info('Emit a reconnected event.');
                // Reset flag
                core._reconnecting = false;
                core.emit('_reconnect');
            }
        })
        .on('reconnect', function (n, delay) {
            core.logger.info('Try to reconnect at %d times.', n);
        })
        .on('disconnect', function (err) {
            core.logger.info('disconnect onto blink %s, start reconnecting. %s', JSON.stringify(err), address);
            // Prevent heart-beat
            core._status = CONST.STATUS.OFFLINE;
            core._reconnecting = true;
        })
        .on('error', function (err) {
            // Do nothing because...
        })
        .connect(address[1], address[0]);
    });

    return promise;
};
